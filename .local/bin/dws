#!/usr/bin/env bash

# Directional window switcher (for X) with cursor movement
# Usage: ./dws [up|down|left|right]

set -euo pipefail

readonly MAX_DISTANCE=999999
readonly DIRECTION_WEIGHT=100
readonly DEPENDENCIES=(wmctrl xdotool xprop xrandr)
readonly INVALID_CLASSES=(panel dock bar notify Conky)

check_dependencies() {
    local missing=()

    for dep in "${DEPENDENCIES[@]}"; do
        command -v "$dep" &>/dev/null || missing+=("$dep")
    done

    (( ${#missing[@]} == 0 )) || die "Missing dependencies: ${missing[*]}"
}

abs_diff() { echo $(($1 < $2 ? $2 - $1 : $1 - $2)); }

die() { echo "Error: $*" >&2; exit 1; }

validate_direction() {
    case "$1" in
        up|down|left|right) return 0 ;;
        *) return 1 ;;
    esac
}

get_window_class() {
    xprop -id "$1" WM_CLASS 2>/dev/null | cut -d'"' -f2
}

is_valid_window_class() {
    local class="$1"

    for invalid in "${INVALID_CLASSES[@]}"; do
        [[ "$class" == *"$invalid"* ]] && return 1
    done

    return 0
}

point_in_rect() {
    local px=$1 py=$2 rx=$3 ry=$4 rw=$5 rh=$6

    (( px >= rx && px <= rx + rw && py >= ry && py <= ry + rh ))
}

is_in_direction() {
    local direction=$1 origin_x=$2 origin_y=$3 target_x=$4 target_y=$5

    case "$direction" in
        left)  (( target_x < origin_x )) ;;
        right) (( target_x > origin_x )) ;;
        up)    (( target_y < origin_y )) ;;
        down)  (( target_y > origin_y )) ;;
    esac
}

distance() {
    local direction=$1 win_center_x=$2 win_center_y=$3
    local current_center_x=$4 current_center_y=$5
    local win_class=$6

    local primary_dist secondary_dist base_distance

    if ! is_in_direction "$direction" "$current_center_x" "$current_center_y" \
                         "$win_center_x" "$win_center_y"; then
        echo -1
        return
    fi

    case "$direction" in
        up)
            primary_dist=$((current_center_y - win_center_y))
            secondary_dist=$(abs_diff "$win_center_x" "$current_center_x")
            ;;
        down)
            primary_dist=$((win_center_y - current_center_y))
            secondary_dist=$(abs_diff "$win_center_x" "$current_center_x")
            ;;
        left)
            primary_dist=$((current_center_x - win_center_x))
            secondary_dist=$(abs_diff "$win_center_y" "$current_center_y")
            ;;
        right)
            primary_dist=$((win_center_x - current_center_x))
            secondary_dist=$(abs_diff "$win_center_y" "$current_center_y")
            ;;
        *)
            echo -1
            return
            ;;
    esac

    base_distance=$((primary_dist * DIRECTION_WEIGHT + secondary_dist))

    if [[ "$win_class" == *desktop* ]]; then
        echo $((base_distance + 500000))
    else
        echo "$base_distance"
    fi
}

find_closest_window() {
    local direction="$1"
    local active_id="$2" current_center_x="$3" current_center_y="$4" current_desktop="$5"

    local best_window="" best_class=""
    local best_distance=$MAX_DISTANCE best_center_x=0 best_center_y=0
    local same_pos_windows=()

    while read -r win_id desktop win_x win_y win_w win_h _; do
        [[ "$desktop" == "$current_desktop" || \
           "$desktop" == "-1" || \
           "$current_desktop" == "-1" ]] || continue

        [[ "$win_id" != "$active_id" || \
           "$desktop" == "-1" || \
           "$current_desktop" == "-1" ]] || continue

        local win_class=$(get_window_class "$win_id")
        is_valid_window_class "$win_class" || continue

        local win_center_x=$((win_x + win_w / 2))
        local win_center_y=$((win_y + win_h / 2))

        if [[ "${win_class,,}" == *desktop* ]] && \
           point_in_rect "$current_center_x" "$current_center_y" "$win_x" "$win_y" \
                         "$win_h" "$win_w"; then
            continue
        fi

        if (( win_center_x == current_center_x && win_center_y == current_center_y )); then
            same_pos_windows+=("$win_id")
            continue
        fi

        local win_distance=$( \
            distance "$direction" "$win_center_x" "$win_center_y" \
           "$current_center_x" "$current_center_y" "$win_class")

        (( win_distance == -1 )) && continue

        if (( win_distance < best_distance )); then
            best_distance=$win_distance
            best_window=$win_id
            best_center_x=$win_center_x
            best_center_y=$win_center_y
            best_class=$win_class
        fi
    done < <(wmctrl -lG)

    if [[ -z "$best_window" && ${#same_pos_windows[@]} -gt 0 ]]; then
        IFS=$'\n' same_pos_windows=($(sort <<< "${same_pos_windows[*]}"))
        local found=false

        for win_id in "${same_pos_windows[@]}"; do
            if [[ "$found" == true ]]; then
                best_window=$win_id
                break
            fi
            if [[ "$win_id" == "$active_id" ]]; then
                found=true
            fi
        done

        if [[ -z "$best_window" ]]; then
            best_window=${same_pos_windows[0]}
        fi

        best_center_x=$current_center_x
        best_center_y=$current_center_y
    fi

    if [[ -n "$best_window" ]]; then
        echo "$best_window $best_center_x $best_center_y $best_class"
        return 0
    else
        return 1
    fi
}

switch_to_window() {
    local window_id=$1 target_x=$2 target_y=$3 target_class=$4

    if [[ "${target_class,,}" == *desktop* ]]; then
        xdotool mousemove "$target_x" "$target_y" click 1
    else
        xdotool windowactivate "$window_id" \
            mousemove "$target_x" "$target_y"
    fi
}

main() {
    (( $# == 1 )) || die "Usage: $0 [up|down|left|right]"
    validate_direction "$1" || die "Invalid direction: $1"

    local direction=$1

    check_dependencies
    pgrep -x unclutter >/dev/null && pkill -USR1 unclutter || true

    local active_info=$(xprop -root _NET_ACTIVE_WINDOW | awk '{print $5}' | tr -d ',')
    local active_id=$(printf "0x%08x" $((active_info)))

    local current_window=$(wmctrl -lG | \
        awk -v active="$active_id" '$1 == active {print $1, $3, $4, $5, $6; exit}')

    if [[ -n "$current_window" ]]; then
        local current_info=($current_window)
        local current_x=${current_info[1]} current_y=${current_info[2]}
        local current_w=${current_info[3]} current_h=${current_info[4]}
        local current_center_x=$((current_x + current_w / 2))
        local current_center_y=$((current_y + current_h / 2))

        local current_desktop=$(wmctrl -d | awk '/\*/ {print $1; exit}')

        if closest_window=$(find_closest_window "$direction" "$active_id" \
                                                "$current_center_x" "$current_center_y" \
                                                "$current_desktop"); then
            local window_info=($closest_window)
            local target_window="${window_info[0]}"
            local target_x="${window_info[1]}"
            local target_y="${window_info[2]}"
            local target_class="${window_info[3]}"

            switch_to_window "$target_window" "$target_x" "$target_y" "$target_class"
            exit 0
        fi
    fi

    die "Current window not found"
}

main "$@"
