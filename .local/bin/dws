#!/usr/bin/env bash

# Directional window switcher (for X) with cursor movement
# Usage: ./dws [up|down|left|right]

set -euo pipefail

readonly MAX_DISTANCE=999999
readonly DIRECTION_WEIGHT=100

check_dependencies() {
    local deps=(wmctrl xdotool xprop xrandr)
    local missing=()

    for dep in "${deps[@]}"; do
        if ! command -v "$dep" &>/dev/null; then
            missing+=("$dep")
        fi
    done

    if (( ${#missing[@]} > 0 )); then
        printf "Error: Missing dependencies: %s\n" "${missing[*]}" >&2
        exit 1
    fi
}

abs_diff() {
    local diff=$(( $1 - $2 ))
    echo $(( diff < 0 ? -diff : diff ))
}

is_in_direction() {
    local direction=$1 origin_x=$2 origin_y=$3 target_x=$4 target_y=$5

    case "$direction" in
        left)
            (( target_x < origin_x )) ;;
        right)
            (( target_x > origin_x )) ;;
        up)
            (( target_y < origin_y )) ;;
        down)
            (( target_y > origin_y )) ;;
        *) return 1 ;;
    esac
}

distance() {
    local direction=$1 win_center_x=$2 win_center_y=$3 current_center_x=$4 current_center_y=$5
    local primary_dist secondary_dist

    if ! is_in_direction "$direction" "$current_center_x" "$current_center_y" "$win_center_x" "$win_center_y"; then
        echo -1
        return
    fi

    case "$direction" in
        up)
            primary_dist=$((current_center_y - win_center_y))
            secondary_dist=$(abs_diff "$win_center_x" "$current_center_x")
            ;;
        down)
            primary_dist=$((win_center_y - current_center_y))
            secondary_dist=$(abs_diff "$win_center_x" "$current_center_x")
            ;;
        left)
            primary_dist=$((current_center_x - win_center_x))
            secondary_dist=$(abs_diff "$win_center_y" "$current_center_y")
            ;;
        right)
            primary_dist=$((win_center_x - current_center_x))
            secondary_dist=$(abs_diff "$win_center_y" "$current_center_y")
            ;;
        *)
            echo -1
            return
            ;;
    esac

    echo $((primary_dist * DIRECTION_WEIGHT + secondary_dist))
}

is_inside_window() {
    local x="$1" y="$2" window_x="$3" window_y="$4" window_h="$5" window_w="$6"

    if (( x >= window_x && x <= window_x + window_w &&
          y >= window_y && y <= window_y + window_h )); then
        return 0
    else
        return 1
    fi
}

find_closest_window() {
    local direction="$1" active_id="$2" current_center_x="$3" current_center_y="$4" current_desktop="$5"
    local best_window="" best_distance=$MAX_DISTANCE best_center_x=0 best_center_y=0
    local same_pos_windows=()

    while read -r win_id desktop win_x win_y win_w win_h _; do
        [[ "$desktop" == "$current_desktop" || "$desktop" == "-1" ]] || continue
        [[ "$win_id" != "$active_id" ]] || continue

        local win_class
        win_class=$(xprop -id "$win_id" WM_CLASS 2>/dev/null | cut -d'"' -f2)
        is_valid_window_class "$win_class" || continue

        local win_center_x=$((win_x + win_w / 2))
        local win_center_y=$((win_y + win_h / 2))


        if [[ "${win_class,,}" == *desktop* ]] && is_inside_window "$current_center_x" "$current_center_y" "$win_x" "$win_y" "$win_h" "$win_w"; then
            continue
        fi

        if (( win_center_x == current_center_x && win_center_y == current_center_y )); then
            same_pos_windows+=("$win_id")
            continue
        fi

        local win_distance
        win_distance=$(distance "$direction" "$win_center_x" "$win_center_y" "$current_center_x" "$current_center_y")
        (( win_distance == -1 )) && continue

        if (( win_distance < best_distance )); then
            best_distance=$win_distance
            best_window=$win_id
            best_center_x=$win_center_x
            best_center_y=$win_center_y
        fi
    done < <(wmctrl -lG)

    if [[ -z "$best_window" && ${#same_pos_windows[@]} -gt 0 ]]; then
        IFS=$'\n' same_pos_windows=($(sort <<< "${same_pos_windows[*]}"))
        local found=false

        for win_id in "${same_pos_windows[@]}"; do
            if [[ "$found" == true ]]; then
                best_window=$win_id
                break
            fi
            if [[ "$win_id" == "$active_id" ]]; then
                found=true
            fi
        done

        if [[ -z "$best_window" ]]; then
            best_window=${same_pos_windows[0]}
        fi

        best_center_x=$current_center_x
        best_center_y=$current_center_y
    fi

    if [[ -n "$best_window" ]]; then
        echo "$best_window $best_center_x $best_center_y"
        return 0
    else
        return 1
    fi
}

find_closest_monitor() {
    local direction=$1 mouse_x=$2 mouse_y=$3
    local active_monitors best_monitor_x="" best_monitor_y="" best_distance=$MAX_DISTANCE

    active_monitors=$(xrandr --listactivemonitors)

    while IFS= read -r line; do
        [[ "$line" =~ ^[[:space:]]*[0-9]+:[[:space:]] ]] || continue

        local monitor_geometry
        monitor_geometry=$(awk '{print $3}' <<< "$line")

        local monitor_w monitor_h monitor_x monitor_y
        monitor_w=${monitor_geometry%%/*}
        monitor_w=${monitor_w%%+*}
        monitor_h=${monitor_geometry#*x}
        monitor_h=${monitor_h%%/*}
        monitor_x=${monitor_geometry#*+}
        monitor_x=${monitor_x%+*}
        monitor_y=${monitor_geometry##*+}

        local monitor_center_x=$((monitor_x + monitor_w / 2))
        local monitor_center_y=$((monitor_y + monitor_h / 2))

        if is_in_direction "$direction" "$mouse_x" "$mouse_y" "$monitor_center_x" "$monitor_center_y"; then
            local distance
            distance=$(distance "$direction" "$monitor_center_x" "$monitor_center_y" "$mouse_x" "$mouse_y")

            if (( distance != -1 && distance < best_distance )); then
                best_distance=$distance
                best_monitor_x=$monitor_center_x
                best_monitor_y=$monitor_center_y
            fi
        fi
    done <<< "$active_monitors"

    if [[ -n "$best_monitor_x" && -n "$best_monitor_y" ]]; then
        echo "$best_monitor_x $best_monitor_y"
        return 0
    else
        return 1
    fi
}

is_valid_window_class() {
    local win_class="${1,,}"

    case "$win_class" in
        *panel*|*dock*|*bar*|*notify*) return 1 ;;
        *) return 0 ;;
    esac
}

main() {
    if (( $# != 1 )); then
        echo "Usage: $0 [up|down|left|right]"
        exit 1
    fi

    local direction="$1"
    case "$direction" in
        up|down|left|right) ;;
        *) echo "Invalid direction. Use: up, down, left, right"; exit 1 ;;
    esac

    check_dependencies

    local active_info active_id
    active_info=$(xprop -root _NET_ACTIVE_WINDOW | awk '{print $5}' | tr -d ',')
    active_id=$(printf "0x%08x" $((active_info)))

    local current_window
    current_window=$(wmctrl -lG | awk -v active="$active_id" '$1 == active {print $1, $3, $4, $5, $6; exit}')

    if [[ -n "$current_window" ]]; then
        local current_info=($current_window)
        local current_x=${current_info[1]} current_y=${current_info[2]}
        local current_w=${current_info[3]} current_h=${current_info[4]}
        local current_center_x=$((current_x + current_w / 2))
        local current_center_y=$((current_y + current_h / 2))

        local current_desktop
        current_desktop=$(wmctrl -d | awk '/\*/ {print $1; exit}')

        local closest_window
        if closest_window=$(find_closest_window "$direction" "$active_id" "$current_center_x" "$current_center_y" "$current_desktop"); then
            local window_info=($closest_window)

            xdotool mousemove "${window_info[1]}" "${window_info[2]}"
            wmctrl -ia "${window_info[0]}"
            exit 0
        fi
    fi


    local mouse_pos mouse_x mouse_y
    mouse_pos=$(xdotool getmouselocation --shell)
    mouse_x=$(awk -F= '/X=/ {print $2}' <<< "$mouse_pos")
    mouse_y=$(awk -F= '/Y=/ {print $2}' <<< "$mouse_pos")

    local closest_monitor
    if closest_monitor=$(find_closest_monitor "$direction" "$mouse_x" "$mouse_y"); then
        local monitor_info=($closest_monitor)
        xdotool mousemove "${monitor_info[0]}" "${monitor_info[1]}"
        exit 0
    fi

    exit 1
}

main "$@"
